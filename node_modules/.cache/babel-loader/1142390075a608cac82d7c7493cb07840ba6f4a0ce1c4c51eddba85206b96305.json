{"ast":null,"code":"import { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useMemo, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst _relativePath = (base, path) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || \"/\" : \"~\" + path;\n\n/**\n * When basepath is `undefined` or '/' it is ignored (we assume it's empty string)\n */\nconst baseDefaults = (base = \"\") => base === \"/\" ? \"\" : base;\nconst absolutePath = (to, base) => to[0] === \"~\" ? to.slice(1) : baseDefaults(base) + to;\nconst relativePath = (base = \"\", path) => _relativePath(unescape(baseDefaults(base)), unescape(path));\n\n/*\n * Removes leading question mark\n */\nconst stripQm = str => str[0] === \"?\" ? str.slice(1) : str;\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = str => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\nconst sanitizeSearch = search => unescape(stripQm(search));\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: x => x\n};\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst Params0 = {},\n  ParamsCtx = createContext(Params0);\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = router => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [relativePath(router.base, location), useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts))];\n};\nconst useLocation = () => useLocationFromRouter(useRouter());\nconst useSearch = () => {\n  const router = useRouter();\n  return sanitizeSearch(router.searchHook(router));\n};\nconst matchRoute = (parser, route, path, loose) => {\n  // if the input is a regexp, skip parsing\n  const {\n    pattern,\n    keys\n  } = route instanceof RegExp ? {\n    keys: false,\n    pattern: route\n  } : parser(route || \"*\", loose);\n\n  // array destructuring loses keys, so this is done in two steps\n  const result = pattern.exec(path) || [];\n\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const [$base, ...matches] = result;\n  return $base !== undefined ? [true, (() => {\n    // for regex paths, `keys` will always be false\n\n    // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n    // we \"zip\" two arrays here to construct the object\n    // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n    const groups = keys !== false ? Object.fromEntries(keys.map((key, i) => [key, matches[i]])) : result.groups;\n\n    // convert the array to an instance of object\n    // this makes it easier to integrate with the existing param implementation\n    let obj = {\n      ...matches\n    };\n\n    // merge named capture groups with matches array\n    groups && Object.assign(obj, groups);\n    return obj;\n  })(),\n  // the third value if only present when parser is in \"loose\" mode,\n  // so that we can extract the base path for nested routes\n  ...(loose ? [$base] : [])] : [false, null];\n};\nconst useRoute = pattern => matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = ({\n  children,\n  ...props\n}) => {\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = props.ssrPath?.split(\"?\") ?? [];\n  if (search) props.ssrSearch = search, props.ssrPath = path;\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = props.hrefs ?? props.hook?.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n  for (let k in parent) {\n    const option = k === \"base\" ? /* base is special case, it is appended to the parent's base */\n    parent[k] + (props[k] || \"\") : props[k] || parent[k];\n    if (prev === next && option !== next[k]) {\n      ref.current = next = {\n        ...next\n      };\n    }\n    next[k] = option;\n\n    // the new router is no different from the parent, use parent\n    if (option !== parent[k]) value = next;\n  }\n  return createElement(RouterCtx.Provider, {\n    value,\n    children\n  });\n};\nconst h_route = ({\n  children,\n  component\n}, params) => {\n  // React-Router style `component` prop\n  if (component) return createElement(component, {\n    params\n  });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\n// a hook to cache the params object between renders (if they are shallow equal)\nconst useCachedParams = value => {\n  let prev = useRef(Params0),\n    curr = prev.current;\n  for (const k in value) if (value[k] !== curr[k]) curr = value;\n  if (Object.keys(value).length === 0) curr = value;\n  return prev.current = curr;\n};\nfunction useSearchParams() {\n  const [location, navigate] = useLocation();\n  const search = useSearch();\n  const searchParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  // cached value before next render, so you can call setSearchParams multiple times\n  let tempSearchParams = searchParams;\n  const setSearchParams = useEvent((nextInit, options) => {\n    tempSearchParams = new URLSearchParams(typeof nextInit === 'function' ? nextInit(tempSearchParams) : nextInit);\n    navigate(location + '?' + tempSearchParams, options);\n  });\n  return [searchParams, setSearchParams];\n}\nconst Route = ({\n  path,\n  nest,\n  match,\n  ...renderProps\n}) => {\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n  const [matches, routeParams, base] =\n  // `match` is a special prop to give up control to the parent,\n  // it is used by the `Switch` to avoid double matching\n  match ?? matchRoute(router.parser, path, location, nest);\n\n  // when `routeParams` is `null` (there was no match), the argument\n  // below becomes {...null} = {}, see the Object Spread specs\n  // https://tc39.es/proposal-object-rest-spread/#AbstractOperations-CopyDataProperties\n  const params = useCachedParams({\n    ...useParams(),\n    ...routeParams\n  });\n  if (!matches) return null;\n  const children = base ? createElement(Router, {\n    base\n  }, h_route(renderProps, params)) : h_route(renderProps, params);\n  return createElement(ParamsCtx.Provider, {\n    value: params,\n    children\n  });\n};\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [currentPath, navigate] = useLocationFromRouter(router);\n  const {\n    to = \"\",\n    href: targetPath = to,\n    onClick: _onClick,\n    asChild,\n    children,\n    className: cls,\n    /* eslint-disable no-unused-vars */\n    replace /* ignore nav props */,\n    state /* ignore nav props */,\n\n    /* eslint-enable no-unused-vars */\n\n    ...restProps\n  } = props;\n  const onClick = useEvent(event => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;\n    _onClick?.(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(targetPath, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(targetPath[0] === \"~\" ? targetPath.slice(1) : router.base + targetPath, router // pass router as a second argument for convinience\n  );\n  return asChild && isValidElement(children) ? cloneElement(children, {\n    onClick,\n    href\n  }) : createElement(\"a\", {\n    ...restProps,\n    onClick,\n    href,\n    // `className` can be a function to apply the class if this link is active\n    className: cls?.call ? cls(currentPath === targetPath) : cls,\n    children,\n    ref\n  });\n});\nconst flattenChildren = children => Array.isArray(children) ? children.flatMap(c => flattenChildren(c && c.type === Fragment ? c.props.children : c)) : [children];\nconst Switch = ({\n  children,\n  location\n}) => {\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n    if (isValidElement(element) &&\n    // we don't require an element to be of type Route,\n    // but we do require it to contain a truthy `path` prop.\n    // this allows to use different components that wrap Route\n    // inside of a switch, for example <AnimatedRoute />.\n    (match = matchRoute(router.parser, element.props.path, location || originalLocation, element.props.nest))[0]) return cloneElement(element, {\n      match\n    });\n  }\n  return null;\n};\nconst Redirect = props => {\n  const {\n    to,\n    href = to\n  } = props;\n  const [, navigate] = useLocation();\n  const redirect = useEvent(() => navigate(to || href, props));\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\nexport { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };","map":{"version":3,"names":["parse","useBrowserLocation","useSearch","useSearch$1","createContext","forwardRef","useEvent","isValidElement","cloneElement","createElement","useContext","useRef","useMemo","useIsomorphicLayoutEffect","Fragment","_relativePath","base","path","toLowerCase","indexOf","slice","length","baseDefaults","absolutePath","to","relativePath","unescape","stripQm","str","decodeURI","_e","sanitizeSearch","search","defaultRouter","hook","searchHook","parser","ssrPath","undefined","ssrSearch","hrefs","x","RouterCtx","useRouter","Params0","ParamsCtx","useParams","useLocationFromRouter","router","location","navigate","navOpts","useLocation","matchRoute","route","loose","pattern","keys","RegExp","result","exec","$base","matches","groups","Object","fromEntries","map","key","i","obj","assign","useRoute","Router","children","props","parent_","parent","value","split","ref","prev","current","next","k","option","Provider","h_route","component","params","useCachedParams","curr","useSearchParams","searchParams","URLSearchParams","tempSearchParams","setSearchParams","nextInit","options","Route","nest","match","renderProps","routeParams","Link","currentPath","href","targetPath","onClick","_onClick","asChild","className","cls","replace","state","restProps","event","ctrlKey","metaKey","altKey","shiftKey","button","defaultPrevented","preventDefault","call","flattenChildren","Array","isArray","flatMap","c","type","Switch","originalLocation","element","Redirect","redirect"],"sources":["/home/kacper/drop-n-share-frontend/node_modules/wouter/esm/index.js"],"sourcesContent":["import { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useMemo, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst _relativePath = (base, path) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n\n/**\n * When basepath is `undefined` or '/' it is ignored (we assume it's empty string)\n */\nconst baseDefaults = (base = \"\") => (base === \"/\" ? \"\" : base);\n\nconst absolutePath = (to, base) =>\n  to[0] === \"~\" ? to.slice(1) : baseDefaults(base) + to;\n\nconst relativePath = (base = \"\", path) =>\n  _relativePath(unescape(baseDefaults(base)), unescape(path));\n\n/*\n * Removes leading question mark\n */\nconst stripQm = (str) => (str[0] === \"?\" ? str.slice(1) : str);\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = (str) => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\n\nconst sanitizeSearch = (search) => unescape(stripQm(search));\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: (x) => x,\n};\n\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst Params0 = {},\n  ParamsCtx = createContext(Params0);\n\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = (router) => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [\n    relativePath(router.base, location),\n    useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts)),\n  ];\n};\n\nconst useLocation = () => useLocationFromRouter(useRouter());\n\nconst useSearch = () => {\n  const router = useRouter();\n  return sanitizeSearch(router.searchHook(router));\n};\n\nconst matchRoute = (parser, route, path, loose) => {\n  // if the input is a regexp, skip parsing\n  const { pattern, keys } =\n    route instanceof RegExp\n      ? { keys: false, pattern: route }\n      : parser(route || \"*\", loose);\n\n  // array destructuring loses keys, so this is done in two steps\n  const result = pattern.exec(path) || [];\n\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const [$base, ...matches] = result;\n\n  return $base !== undefined\n    ? [\n        true,\n\n        (() => {\n          // for regex paths, `keys` will always be false\n\n          // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n          // we \"zip\" two arrays here to construct the object\n          // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n          const groups =\n            keys !== false\n              ? Object.fromEntries(keys.map((key, i) => [key, matches[i]]))\n              : result.groups;\n\n          // convert the array to an instance of object\n          // this makes it easier to integrate with the existing param implementation\n          let obj = { ...matches };\n\n          // merge named capture groups with matches array\n          groups && Object.assign(obj, groups);\n\n          return obj;\n        })(),\n\n        // the third value if only present when parser is in \"loose\" mode,\n        // so that we can extract the base path for nested routes\n        ...(loose ? [$base] : []),\n      ]\n    : [false, null];\n};\n\nconst useRoute = (pattern) =>\n  matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = ({ children, ...props }) => {\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = props.ssrPath?.split(\"?\") ?? [];\n  if (search) (props.ssrSearch = search), (props.ssrPath = path);\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = props.hrefs ?? props.hook?.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n\n  for (let k in parent) {\n    const option =\n      k === \"base\"\n        ? /* base is special case, it is appended to the parent's base */\n          parent[k] + (props[k] || \"\")\n        : props[k] || parent[k];\n\n    if (prev === next && option !== next[k]) {\n      ref.current = next = { ...next };\n    }\n\n    next[k] = option;\n\n    // the new router is no different from the parent, use parent\n    if (option !== parent[k]) value = next;\n  }\n\n  return createElement(RouterCtx.Provider, { value, children });\n};\n\nconst h_route = ({ children, component }, params) => {\n  // React-Router style `component` prop\n  if (component) return createElement(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\n// a hook to cache the params object between renders (if they are shallow equal)\nconst useCachedParams = (value) => {\n  let prev = useRef(Params0),\n    curr = prev.current;\n\n  for (const k in value) if (value[k] !== curr[k]) curr = value;\n  if (Object.keys(value).length === 0) curr = value;\n  return (prev.current = curr);\n};\n\nfunction useSearchParams() {\n  const [location, navigate] = useLocation();\n\n  const search = useSearch();\n  const searchParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  // cached value before next render, so you can call setSearchParams multiple times\n  let tempSearchParams = searchParams;\n\n  const setSearchParams = useEvent((nextInit, options) => {\n    tempSearchParams = new URLSearchParams(\n      typeof nextInit === 'function' ? nextInit(tempSearchParams) : nextInit,\n    );\n    navigate(location + '?' + tempSearchParams, options);\n  });\n\n  return [searchParams, setSearchParams];\n}\n\nconst Route = ({ path, nest, match, ...renderProps }) => {\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n\n  const [matches, routeParams, base] =\n    // `match` is a special prop to give up control to the parent,\n    // it is used by the `Switch` to avoid double matching\n    match ?? matchRoute(router.parser, path, location, nest);\n\n  // when `routeParams` is `null` (there was no match), the argument\n  // below becomes {...null} = {}, see the Object Spread specs\n  // https://tc39.es/proposal-object-rest-spread/#AbstractOperations-CopyDataProperties\n  const params = useCachedParams({ ...useParams(), ...routeParams });\n\n  if (!matches) return null;\n\n  const children = base\n    ? createElement(Router, { base }, h_route(renderProps, params))\n    : h_route(renderProps, params);\n\n  return createElement(ParamsCtx.Provider, { value: params, children });\n};\n\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [currentPath, navigate] = useLocationFromRouter(router);\n\n  const {\n    to = \"\",\n    href: targetPath = to,\n    onClick: _onClick,\n    asChild,\n    children,\n    className: cls,\n    /* eslint-disable no-unused-vars */\n    replace /* ignore nav props */,\n    state /* ignore nav props */,\n    /* eslint-enable no-unused-vars */\n\n    ...restProps\n  } = props;\n\n  const onClick = useEvent((event) => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (\n      event.ctrlKey ||\n      event.metaKey ||\n      event.altKey ||\n      event.shiftKey ||\n      event.button !== 0\n    )\n      return;\n\n    _onClick?.(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(targetPath, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(\n    targetPath[0] === \"~\" ? targetPath.slice(1) : router.base + targetPath,\n    router // pass router as a second argument for convinience\n  );\n\n  return asChild && isValidElement(children)\n    ? cloneElement(children, { onClick, href })\n    : createElement(\"a\", {\n        ...restProps,\n        onClick,\n        href,\n        // `className` can be a function to apply the class if this link is active\n        className: cls?.call ? cls(currentPath === targetPath) : cls,\n        children,\n        ref,\n      });\n});\n\nconst flattenChildren = (children) =>\n  Array.isArray(children)\n    ? children.flatMap((c) =>\n        flattenChildren(c && c.type === Fragment ? c.props.children : c)\n      )\n    : [children];\n\nconst Switch = ({ children, location }) => {\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = matchRoute(\n        router.parser,\n        element.props.path,\n        location || originalLocation,\n        element.props.nest\n      ))[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nconst Redirect = (props) => {\n  const { to, href = to } = props;\n  const [, navigate] = useLocation();\n  const redirect = useEvent(() => navigate(to || href, props));\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\n\nexport { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}